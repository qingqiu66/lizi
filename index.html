<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>èµ›åšç²’å­</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: "Microsoft YaHei", sans-serif; }
        
        /* å¼¹çª—æ ·å¼ï¼šåŠé€æ˜æ¯›ç»ç’ƒ */
        #setup-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999; /* ä¿è¯åœ¨æœ€é¡¶å±‚ */
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(8px);
            transition: opacity 0.5s ease;
        }
        .modal-content {
            width: 420px; padding: 40px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.1);
            background: rgba(10, 10, 10, 0.95);
            text-align: center; color: #00f3ff;
            border-radius: 16px;
        }
        .input-group { margin: 20px 0; text-align: left; }
        .input-group label { display: block; margin-bottom: 6px; color: #888; font-size: 13px; }
        input[type="text"] {
            width: 100%; padding: 10px; background: #111; border: 1px solid #333; 
            color: white; font-size: 16px; border-radius: 6px; outline: none;
        }
        input[type="text"]:focus { border-color: #00f3ff; }
        
        button#launch-btn {
            width: 100%; padding: 14px; margin-top: 20px;
            background: linear-gradient(90deg, #00f3ff, #0055ff);
            color: #fff; font-weight: bold; border: none; border-radius: 8px;
            cursor: pointer; font-size: 16px; letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }
        button#launch-btn:hover { filter: brightness(1.2); }

        /* å·¦ä¸Šè§’é¢„è§ˆæ¡† (ä¿®å¤å±‚çº§é—®é¢˜) */
        #preview-container {
            position: absolute; top: 20px; left: 20px; z-index: 100; /* ç¡®ä¿åœ¨ç²’å­ä¹‹ä¸Š */
            width: 180px; height: 135px;
            border: 1px solid rgba(0, 243, 255, 0.3); 
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px; overflow: hidden;
            opacity: 0; transition: opacity 0.5s;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€ï¼Œä¸æŒ¡ä½æ“ä½œ */
        }
        #video-input { display: none; }
        #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

        /* çŠ¶æ€æ–‡å­— */
        .ui-label {
            position: absolute; bottom: 30px; left: 30px; z-index: 50;
            color: rgba(255,255,255,0.7); font-size: 14px; pointer-events: none; opacity: 0;
            text-shadow: 0 0 5px #00f3ff;
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .highlight { color: #00f3ff; font-weight: bold; }
        
        /* ThreeJS Canvas */
        canvas[data-engine="three.js"] { position: fixed; top: 0; left: 0; z-index: 0; }
        /* GitHub æ¯›ç»ç’ƒæŒ‰é’® */
        #github-link {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 50;
            width: 48px;
            height: 48px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }
        #github-link:hover {
            background: rgba(0, 243, 255, 0.15);
            border-color: rgba(0, 243, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: translateY(-3px);
        }
        #github-link svg {
            width: 26px;
            height: 26px;
            fill: rgba(255, 255, 255, 0.7);
            transition: fill 0.3s ease;
        }
        #github-link:hover svg {
            fill: #00f3ff;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="setup-modal">
    <div class="modal-content">
        <h2>ç³»ç»Ÿå¯åŠ¨</h2>
        <div class="input-group">
            <label>æ˜¾ç¤ºæ–‡å­—</label>
            <input type="text" id="user-text" value="èµ›åšç²’å­" placeholder="è¾“å…¥æ–‡å­—...">
        </div>
        <div class="input-group">
            <label>ä¸Šä¼ å›¾ç‰‡ (å¯é€‰)</label>
            <input type="file" id="user-image" accept="image/*" style="display:block; font-size:12px; color:#666">
        </div>
        <button id="launch-btn">åˆå§‹åŒ–</button>
    </div>
</div>

<div id="preview-container">
    <video id="video-input"></video>
    <canvas id="output-canvas" width="320" height="240"></canvas>
</div>

<div class="ui-label">
    [ SYSTEM ] <span id="status-text" class="highlight">WAITING...</span><br>
    ğŸ– å¼ æ‰‹ = ç²’å­çˆ†å‘ | âœŠ æ¡æ‹³ = èšåˆæ˜¾ç¤º
</div>
<a href="https://github.com/qingqiu66/lizi" target="_blank" id="github-link" title="æŸ¥çœ‹Github">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
    </svg>
</a>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // === å…³é”®å‚æ•°è°ƒæ•´ ===
    const CONFIG = {
        particleCount: 55000,   // é«˜å¯†åº¦
        baseSize: 3.5,     
        bloomStrength: 1.3,    
        bloomThreshold: 0.2, 
        colors: [new THREE.Color('#00eaff'), new THREE.Color('#ff0055')]
    };

    let scene, camera, renderer, composer, points;
    let gestureIntensity = 1.0; 
    let smoothedIntensity = 1.0;
    let lastHandTime = 0;
    let isAutoMode = true;

    // UI äº¤äº’
    const launchBtn = document.getElementById('launch-btn');
    const setupModal = document.getElementById('setup-modal');

    launchBtn.addEventListener('click', async () => {
        launchBtn.innerText = "LOADING...";
        const textVal = document.getElementById('user-text').value || "èµ›åšç²’å­";
        const fileInput = document.getElementById('user-image');
        
        let imgUrl = null;
        if(fileInput.files[0]) {
            imgUrl = URL.createObjectURL(fileInput.files[0]);
        }

        // éšè—å¼¹çª—
        setupModal.style.opacity = 0;
        setTimeout(() => setupModal.style.display = 'none', 500);
        
        // æ˜¾ç¤º UI
        document.querySelector('.ui-label').style.opacity = 1;
        document.getElementById('preview-container').style.opacity = 1;
        
        // ç”Ÿæˆå†…å®¹
        await createParticles(textVal, imgUrl);
        
        // å¯åŠ¨æ‘„åƒå¤´
        initCamera();
        
        // æ ‡è®°ï¼šå¦‚æœæ‘„åƒå¤´ä¸€ç›´æ²¡æ•°æ®ï¼Œ3ç§’åæ‰è‡ªåŠ¨æ¼”ç¤ºï¼Œé¿å…æŠ¢å¤ºæ§åˆ¶æƒ
        lastHandTime = performance.now(); 
    });

    // --- 1. åœºæ™¯åˆå§‹åŒ– ---
    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.002); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 130;

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.domElement.setAttribute('data-engine', 'three.js'); // ç”¨äºCSSå®šä½
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        
        // ä¿®å¤è¿‡æ›é—®é¢˜çš„å…³é”®å‚æ•°
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength; 
        bloomPass.radius = 0.4;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8; 

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- 2. ç²’å­ç”Ÿæˆ  ---
    async function createParticles(text, imageSrc) {
        if(points) { scene.remove(points); points.geometry.dispose(); }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = 1024; 
        canvas.width = size; canvas.height = size;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, size, size);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

        let img = null;
        if (imageSrc) {
            try {
                img = await new Promise((resolve) => {
                    const i = new Image();
                    i.onload = () => resolve(i);
                    i.onerror = () => resolve(null);
                    i.src = imageSrc;
                });
            } catch(e) {}
        }

        ctx.fillStyle = '#ffffff';
        if (img) {
            const aspect = img.width / img.height;
            let drawW = size * 0.75; // ç¨å¾®ç¼©ç‚¹ï¼Œç•™å‡ºè¾¹è·
            let drawH = drawW / aspect;
            if(drawH > size * 0.75) { drawH = size * 0.75; drawW = drawH * aspect; }
            ctx.drawImage(img, (size - drawW)/2, (size - drawH)/2, drawW, drawH);
            
            if(text && text !== "èµ›åšç²’å­") {
                ctx.font = 'bold 80px "Microsoft YaHei"';
                ctx.fillText(text, size/2, size - 80);
            }
        } else {
            ctx.font = '900 220px "Microsoft YaHei", sans-serif';
            ctx.fillText(text, size/2, size/2);
        }

        const data = ctx.getImageData(0, 0, size, size).data;
        const targetPositions = [];
        
        // å¢åŠ é‡‡æ ·å¯†åº¦ï¼Œä¿è¯ç»†èŠ‚
        for(let y=0; y<size; y+=3) { 
            for(let x=0; x<size; x+=3) {
                if(data[(y*size+x)*4] > 60) {
                    const px = (x - size/2) * 0.35;
                    const py = -(y - size/2) * 0.35;
                    // åšåº¦æ§åˆ¶åœ¨ +/- 4ï¼Œæ—¢æœ‰ç«‹ä½“æ„Ÿåˆä¸ä¼šç³Š
                    const pz = (Math.random() - 0.5) * 8.0; 
                    targetPositions.push(px, py, pz);
                }
            }
        }

        // å…œåº•é€»è¾‘
        if(targetPositions.length < 100) {
            for(let i=0; i<3000; i++) {
                const angle = i * 0.05;
                targetPositions.push(Math.cos(angle)*40, Math.sin(angle)*40, (Math.random()-0.5)*10);
            }
        }

        const count = CONFIG.particleCount;
        const posArr = new Float32Array(count * 3);
        const targetArr = new Float32Array(count * 3);
        const randomArr = new Float32Array(count * 3);
        const colorArr = new Float32Array(count * 3);
        const sizeArr = new Float32Array(count);

        for(let i=0; i<count; i++) {
            const tIdx = i % (targetPositions.length / 3);
            targetArr[i*3] = targetPositions[tIdx*3];
            targetArr[i*3+1] = targetPositions[tIdx*3+1];
            targetArr[i*3+2] = targetPositions[tIdx*3+2];

            const r = 180 + Math.random() * 180;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            randomArr[i*3] = r * Math.sin(phi) * Math.cos(theta);
            randomArr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            randomArr[i*3+2] = r * Math.cos(phi);

            posArr[i*3] = randomArr[i*3];
            posArr[i*3+1] = randomArr[i*3+1];
            posArr[i*3+2] = randomArr[i*3+2];

            const c = Math.random() > 0.5 ? CONFIG.colors[0] : CONFIG.colors[1];
            colorArr[i*3] = c.r; colorArr[i*3+1] = c.g; colorArr[i*3+2] = c.b;
            sizeArr[i] = Math.random(); 
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geo.setAttribute('aTarget', new THREE.BufferAttribute(targetArr, 3));
        geo.setAttribute('aRandom', new THREE.BufferAttribute(randomArr, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));

        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uBaseSize: { value: CONFIG.baseSize }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uProgress;
                uniform float uBaseSize;
                attribute vec3 aTarget;
                attribute vec3 aRandom;
                attribute vec3 color;
                attribute float size;
                varying vec3 vColor;
                varying float vProgress;

                void main(){
                    vColor = color;
                    float t = smoothstep(0.0, 1.0, uProgress);
                    vProgress = t;

                    vec3 pos = mix(aRandom, aTarget, t);

                    // æ•£å¼€æ—¶åŠ å™ªç‚¹
                    if(t < 0.8) {
                        float noise = sin(pos.y * 0.2 + uTime * 2.0);
                        pos.x += noise * (1.0 - t) * 3.0;
                    }
                    
                    // èšåˆæ—¶ç¨³å®šï¼Œåªåšå¾®å¼±å‘¼å¸
                    if(t > 0.9) {
                        pos.z += sin(uTime) * 1.5;
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    // å‡å°ç³»æ•° 100.0 (åŸ 150.0)ï¼Œé˜²æ­¢è¿‡å¤§
                    gl_PointSize = size * uBaseSize * (100.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vProgress;
                void main(){
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d > 0.5) discard;
                    
                    // æ ¸å¿ƒäº®ï¼Œè¾¹ç¼˜å¿«é€Ÿè¡°å‡ -> é”åŒ–æ•ˆæœ
                    float glow = 1.0 - d * 2.0;
                    glow = pow(glow, 2.5); 
                    
                    gl_FragColor = vec4(vColor, glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);
    }

    // --- 3. æ‘„åƒå¤´ä¿®å¤ ---
    async function initCamera() {
        if (!window.Hands) { console.error("MediaPipe Load Failed"); return; }
        
        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });

        hands.onResults(results => {
            // æ¸…ç©ºç”»å¸ƒï¼Œä¿æŒé€æ˜
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // åªè¦æ£€æµ‹åˆ°æ‰‹ï¼Œç«‹å³å–æ¶ˆè‡ªåŠ¨æ¨¡å¼
                isAutoMode = false;
                lastHandTime = performance.now();

                const lm = results.multiHandLandmarks[0];
                
                // ç»˜åˆ¶éª¨éª¼ (é’è‰²è¿æ¥çº¿ï¼Œçº¢è‰²å…³èŠ‚)
                if(window.drawConnectors) drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00f3ff', lineWidth: 2});
                if(window.drawLandmarks) drawLandmarks(ctx, lm, {color: '#ff0055', lineWidth: 1});
                
                // è®¡ç®—æ¯”ä¾‹ï¼šæ‰‹æŒ‡é•¿åº¦ / æ‰‹æŒé•¿åº¦ (é€‚åº”è¿œè¿‘)
                const wrist = lm[0];
                const tip = lm[12]; // ä¸­æŒ‡å°–
                const mcp = lm[9];  // ä¸­æŒ‡æ ¹
                const palmLen = Math.sqrt(Math.pow(mcp.x - wrist.x, 2) + Math.pow(mcp.y - wrist.y, 2));
                const fingerLen = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                
                const ratio = fingerLen / palmLen;
                // ratio > 2.0 çº¦ä¸ºå¼ å¼€ï¼Œ ratio < 1.2 çº¦ä¸ºæ¡æ‹³
                let val = (ratio - 1.2) / (2.0 - 1.2); 
                val = Math.max(0, Math.min(1, val));
                
                gestureIntensity = val;
                
                document.getElementById('status-text').innerText = `CONTROL: ${(val*100).toFixed(0)}%`;
                document.getElementById('status-text').style.color = '#00f3ff';
            } else {
                // ä¸¢å¤±æ‰‹åŠ¿
                document.getElementById('status-text').innerText = "SEARCHING...";
                document.getElementById('status-text').style.color = '#555';
                
                // å¦‚æœè¶…è¿‡3ç§’æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œæ‰è¿›å…¥è‡ªåŠ¨æ¨¡å¼
                if (performance.now() - lastHandTime > 3000) {
                    isAutoMode = true;
                }
            }
        });

        const video = document.getElementById('video-input');
        const camera = new window.Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 320, height: 240
        });
        
        try {
            await camera.start();
            console.log("Camera started");
        } catch (e) {
            console.error("Camera failed", e);
            document.getElementById('status-text').innerText = "CAMERA ERROR";
        }
    }

    // --- 4. åŠ¨ç”»å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001;

        if (isAutoMode) {
            gestureIntensity = (Math.sin(time * 0.8) + 1) * 0.5;
        }

        smoothedIntensity += (gestureIntensity - smoothedIntensity) * 0.08;
        const uProg = 1.0 - smoothedIntensity;

        if(points) {
            points.material.uniforms.uTime.value = time;
            points.material.uniforms.uProgress.value = uProg;
        }
        composer.render();
    }

    initScene();
    createParticles("èµ›åšç²’å­", null); // é»˜è®¤é¢„è§ˆ
    animate();

</script>
</body>
</html>